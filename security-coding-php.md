# Безопасное программирование на PHP и JavaScript

***

## 1. Безопасные запросы к базе данных и защита от MySQL-injection атак

Для того, чтобы предотвратить большинство SQL-атак необходимо соблюдать 2 правила:
1.	Все запросы должны совершаться к БД через PDO, где параметры передаются (биндятся) массивом или аргументами функции.
2.	Передаваемые названия полей (колонок) и таблиц должны быть описанны текстом или выбираться из подготовленного списка названий (смотри п. 1.3).

### 1.1. Примеры правильных запросов с PDO
**Пример 1:** Здесь параметр для good_id эскейпится автоматически средствами mysqli
```php
$sql = 'SELECT * FROM goods WHERE good_id = ?';
$result = $db->fetchAll($sql, 2);
```
**Пример 2:** Массив параметров $isoAlpha2 эскейпится автоматически
```php
$db->select()->from('geo.ports', ['id','value'=>'name','lat'=>'latitude','lng'=>'longitude'])
    ->where('id_region @> ARRAY[?]',$isoAlpha2)
    ->order('name ASC')
    ->query()
    ->fetchAll();
```
**Пример 3:** Пример эквивалентный примеру №1, только с использованием query builder'a
```php 
$db->select()->from('geo.ports', ['id','value'=>'name','terminal'])
    ->where('country=?', $country)
    ->order('name ASC')
    ->query()
    ->fetchAll();
```
**Пример 4.** Колонки указаны массивом
```php
$db->select()->from('profiles', ['id', 'id_user', 'email', 'first_name', 'last_name', 'country']);
```
**Пример 5.** Именованные параметры
```php
$sql = 'SELECT * FROM bugs WHERE ' .
       'reported_by = :reporter AND bug_status = :status';
$db->query( $sql, ['reporter' => 'goofy', 'status' => 'FIXED'] );
```
**Пример 6.** Поиск по LIKE
```php
$searchText = $_GET['search'];
$sql = 'SELECT * FROM posts WHERE ' .
       'content LIKE :search_str;
$db->query( $sql, ['search_str' => '%'.$searchText.'%'] );
```
**Пример 7.** Безопасный IN в PDO, когда удобней провести implode
```php
$completionNo = implode(",", $data);
$select = $db->select()
	->from( ["property_master"], ['id', 'completion_no', 'total_carpet_area'] )
	->where("completion_no IN (?)", $completionNo);
```



### 1.2. Примеры НЕправильных запросов без PDO
`Категорически запрещено использовать такие способы вызова и оформления запросов`
**Пример 1.** Передача параметров через конкатенацию
```php
$sql = 'SELECT * FROM bugs WHERE bug_id = '.$myparam;
$result = $db->fetchAll($sql);
```
**Пример 2.** Передача параметров через php parser внутри двойных кавычек
```php
$sql = "SELECT * FROM bugs WHERE bug_id = $myparam";
$result = $db->fetchAll($sql);
```
**Пример 3.** Указание имени таблицы через php parser внутри двойных кавычек, а не средствами PDO:
```php
$sql = "SELECT * FROM $table";
$result = $db->fetchAll($sql);
```
**Пример 4.** Указание колонок через php parser внутри двойных кавычек, а не средствами PDO:
```php
$sql = "SELECT $fields FROM users";
$result = $db->fetchAll($sql);
```
**Пример 5.** Использование не верифицированных имен полей и таблиц - позволяет осуществить mysql blind injection:
```php
$sql = 'SELECT ? FROM ? WHERE bug_id = ?';
$result = $db->fetchAll($sql, $_GET['myparam1'], $_POST['hallo'], 123);
```

### 1.3. Примеры правильных запросов для выборки с произвольным наборок колонок и произвольными таблицами
```php
// список названий таблиц, которые разрешены к использованию
$allowTables = [ 'fruits', 'animals', 'tables' ];

// проверяем название таблицы по разрешенному списку таблиц
if ( in_array($allowTables[ $_POST['table'] ], $allowTables) ) { 
    // подставляем имя таблицы в функцию "from" query builder'a
    $result = $db->query()->from( $_POST['table'] )->fetchAll();
    
    // или непосредственно в SQL
    $sql = "SELECT * FROM ?";
    $result = $db->fetchAll($sql, $_POST['table']);
}
```

```php
// список разрешенных полей/колонок
$allowCols = [ 'id', 'name', 'weight' ];
if ( in_array( $_GET['myparam1'], $allowCols ) ) {
    $sql = 'SELECT ? FROM users WHERE bug_id = ?';
    $result = $db->fetchAll($sql, $_GET['myparam1'], 123);
}
```
*Обратите внимание, что названия таблиц и полей не передаются напрямую. Они должно пройди верификацию по разрешенному списку названий, например с использованием in_array для списка названий.*

### 1.4. OR, AND, IN, JOIN

Могут возникнуть ситуации с использованием большого количества OR и AND в запросе, когда часть SQL генерируется функциями, либо используется JOIN или IN. В таких запросах также всегда использовать PDO, а массив с параметрами формировать самостоятельно с учетом порядка следования.

1. Вариант. Использование оператора IN
```php
$regions = [ 144, 145, 146 ];
$db->select()->from('geo.ports', ['id','value'=>'name','lat'=>'latitude','lng'=>'longitude'])
    ->where('id_region IN (?)', $regions)
    ->order('name ASC')
    ->query()
    ->fetchAll();
```
2. Вариант. Использование Postgress типа ARRAY вместе с PDO. В данном примере поле id_region - это массив
```php
$regions = [ 144, 145, 146 ];
$db->select()->from('geo.ports', ['id','value'=>'name','lat'=>'latitude','lng'=>'longitude'])
    ->where('id_region @> ARRAY[?]', $regions)
    ->order('name ASC')
    ->query()
    ->fetchAll();
```
3. Вариант. Генерации IN/AND логики
```php
$select = $db->select()->from('products',
        array('product_id', 'product_name', 'price'))
    ->where('price < ?', $minimumPrice)
    ->orWhere('price > ?', $maximumPrice);
```
4. Вариант. Join'ы
```php
$select = $db
    ->select()
    ->from('users', array('user_id', 'email_address'))
    ->joinLeft(
        array('t1' => $user_multivalued),
        't1.user_id = users.user_id',
        array('languages'=>'value')
    )
    ->where('list_id = ?', 45)
```

Возможно исключение для некоторых SQL запросов, где не используется PDO. 
Когда возможно такое применять:
1.	Когда в запросе нет передаваемых из переменных параметров
2.	Какой-то супер-особый запрос, который нельзя реализовать через PDO, **который обязательно надо согласовать с руководителем проекта!!!*** В противном случае категорически запрещено использовать запросы без PDO.

## 2. Безопасный вывод данных и защита от XSS-атак

Для вывода текстовых данных из базы данных и всех данных полученных в запросах (post, get) при выводе текста в шаблоне использовать функцию $this->escape или $this->escapeHtml (зависит от версии).

Применять её в такой композиции **<?=$this->escape($myField)?>**
- Не использовать для текстов переводов.
- Не использовать когда произведено преобразование типа INT или FLOAT.
- Во всех остальных случаях использование обязательно.

`Вывод текста без экранивания категорически запрещен!`

**Из документации Zend:**
*По умолчанию метод escape() использует функцию PHP htmlspecialchars() для экранирования.*

При передаче подобных данных через JSON, данные преобразования необходимо провести на стороне JS, либо предварительно, средствами Zend: escape/escapeHtml или php: htmlspecialchars на стороне сервера.

В jQuery/JS предотвратить XSS инъекцию можно используя $el.text( text ) или $el.innerTEXT = text, вместо $el.html( text ) или $el.innerHTML = text.

`Будьте внимательны!`

В REACT’е выводимые данные эскейпятся автоматически, но всё же лучше проверить!


### 3. Загрузка файлов на сервер
`Категорически запрещено загружать файлы в произвольные папки!`

**Любые файлы, которые загружаются на сервер посредством форм или ссылок, указанных пользователем должны складироваться в строго определенной руководителем проекта папке.**

Предварительно, руководитель проекта должен проверить, правильно ли настроены параметры папки для загрузки файлов и запрещено ли в этой папке исполнение скриптов.

Для загружаемых файлов необходимо генерировать новое название используя хеш функцию и подставить требуемое разрешение.

В некоторых случах, когда необходимо точно понимать тип файла рекомендуется использовать функции для определения mime-type, но даже в таких случаях генерировать новое название для файла.

#### Как предотвратить подобную ошибку

Попробуйте загрузить в папку для загрузки файл с разрешением .php и каким-нибудь рабочим кодом внутри.
Введите в браузере полный URL к этому файлу, если php отработает успешно, то необходимо сообщить руководителю проекта о найденной уязвимости.
**Это профессиональный подход!**

### 4. Пароли, пинкоды и капчи

Минимальная длина пароля (регистрация/авторизация) – 8 символов
Максимальная длина пароля (регистрация/авторизация) – 100 символов
Длина пин-кода (короткий цифровой пароль) - 4 символа
Минимальная длина контрольного числа (Google Authentificator, Email verify) - 6 символов
Минимальный размер текста капчи - 4 символа

### 5. Хеши

Генерировать хэши рекомендуется функцией **sha256**.

Где рекомендовано использовать:
- хранение паролей
- генерация уникальных ссылок (восстановления пароля, подтверждения и т.п.)
- генерация имен файлов
- сравнение данных